/*
 * Copyright 2021 The University of Manchester
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.acuity.visualisations.rawdatamodel.dataset.info;

import com.acuity.visualisations.rawdatamodel.vo.StudyRules;
import com.acuity.va.security.acl.domain.ClinicalStudy;
import com.acuity.va.security.acl.domain.Dataset;
import com.acuity.va.security.acl.domain.Datasets;
import com.acuity.va.security.acl.domain.DrugProgramme;
import com.acuity.va.security.acl.domain.AcuityObjectIdentity;
import com.acuity.va.security.acl.domain.AcuityObjectIdentityImpl;
import com.acuity.va.security.acl.domain.vasecurity.ClinicalStudyInfo;
import com.acuity.va.security.acl.domain.vasecurity.DatasetInfo;
import com.acuity.va.security.acl.domain.vasecurity.DrugProgrammeInfo;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.acls.model.NotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static com.acuity.va.security.acl.domain.AcuityObjectIdentityImpl.Origin.ACUITY;
import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toSet;

/**
 * @author Glen
 */
@Component
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Slf4j
public class InfoService {

    private final InfoRepository infoRepository;
    private final DrugProgrammeRepository drugProgrammeRepository;
    private final InfoDatasetRepository infoDatasetRepository;
    private final InfoStudyRepository infoStudyRepository;

    /**
     * Detect only has studies in the db (with ids), so a list of them is queried (as DetectVisualisations), and then DetectDrugProgrammes and
     * DetectClinicalStudies are generated for these.
     *
     * @return all AcuityObjectIdentity
     */
    public List<AcuityObjectIdentity> generateObjectIdentities() {

        List<AcuityObjectIdentity> returnedObjectIdentities = newArrayList();

        // dps and datasets
        List<AcuityObjectIdentity> listObjectIdentitiesInDB = infoRepository.listObjectIdentities(); // ids from the db

        // TODO swap
        Set<DrugProgramme> acuityDrugProgrammes = listObjectIdentitiesInDB.stream().filter(roi -> roi != null && roi.thisDatasetType()).map(roi -> {
            if (roi.thisDatasetType()) {
                String dpName = ((Dataset) roi).getDrugProgramme();
                DrugProgramme dp = new DrugProgramme(dpName);
                dp.setOrigin(ACUITY);

                return dp;
            }

            return null;
        }).collect(toSet());

        // generate Clinical Studies (auto generated ids)
        Set<ClinicalStudy> acuityClinicalStudies
                = listObjectIdentitiesInDB.stream().filter(roi -> roi != null && roi.thisDatasetType()).map(roi -> {
            String csCode = ((Dataset) roi).getClinicalStudyCode();
            String csName = ((Dataset) roi).getClinicalStudyName();
            ClinicalStudy cs = new ClinicalStudy(csCode, csName);
            cs.setDrugProgramme(((Dataset) roi).getDrugProgramme());
            cs.setOrigin(ACUITY);

            return cs;
        }).collect(toSet());

        // Find dp
        Set<AcuityObjectIdentity> acuityDatasets
                = listObjectIdentitiesInDB.stream().filter(roi -> roi != null && roi.thisDatasetType()).collect(toSet());

        returnedObjectIdentities.addAll(acuityDrugProgrammes);
        returnedObjectIdentities.addAll(acuityClinicalStudies);
        returnedObjectIdentities.addAll(acuityDatasets);

        return returnedObjectIdentities;
    }

    /**
     * Creates drugProgrammeInfo object and then uses the vASecurityInfoDrugProgrammeRepository to populate the rest of the information
     */
    public DrugProgrammeInfo getDrugProgrammeInfo(DrugProgramme drugProgramme) {
        // need to find the name
        List<String> listDrugProgrammes = drugProgrammeRepository.listDrugProgrammes();

        // DrugProgramme will only have id and no name so need to find it
        String findDrugProgrammesNameFromAutoGeneratedLong
                = listDrugProgrammes.stream().filter(dgName -> new DrugProgramme(dgName).getId().equals(drugProgramme.getId())).findFirst().orElse(null);
        if (findDrugProgrammesNameFromAutoGeneratedLong == null) { // not found
            throw new NotFoundException("DrugProgrammeInfo: " + drugProgramme.getId() + " not found");
        }

        DrugProgramme detectDrugProgramme = new DrugProgramme(findDrugProgrammesNameFromAutoGeneratedLong);
        DrugProgrammeInfo drugProgrammeInfo = drugProgrammeRepository.getDrugProgrammeInfo(detectDrugProgramme);

        if (drugProgrammeInfo == null) { // not found
            throw new NotFoundException("DrugProgrammeInfo: " + drugProgramme.getId() + " not found");
        }

        return drugProgrammeInfo;
    }

    /**
     * Creates datasetsInfo object and then uses the vASecurityInfoVisualisationAndStudyRepository to populate the rest of the information
     */
    public DatasetInfo getDatasetInfo(Dataset dataset) {
        DatasetInfo datasetInfo = infoDatasetRepository.getDatasetInfo(dataset);

        if (datasetInfo == null) { // not found
            throw new NotFoundException("DatasetInfo: " + dataset + " not found");
        }

        return datasetInfo;
    }

    /**
     * Creates clinicalStudyInfo object and then uses the vASecurityInfoVisualisationAndStudyRepository to populate the rest of the information
     */
    public ClinicalStudyInfo getClinicalStudyInfo(ClinicalStudy clinicalStudy) {
        Long clinicalStudyId = clinicalStudy.getId();

        // need to find the name
        List<String> listClinicalStudyCodes = infoStudyRepository.listClinicalStudyCodes();

        listClinicalStudyCodes.forEach(csCode -> log.info(csCode + "  " + new ClinicalStudy(csCode).getId()));
        // ClinicalStudies will only have id and no name so need to find it
        String clinicalStudiesNameFromAutoGeneratedLong
                = listClinicalStudyCodes.stream().filter(csCode -> new ClinicalStudy(csCode).getId().equals(clinicalStudy.getId())).findFirst().orElse(null);

        if (clinicalStudiesNameFromAutoGeneratedLong == null) { // not found
            throw new NotFoundException("ClinicalStudyInfo: " + clinicalStudy.getId() + " not found");
        }

        ClinicalStudy acuityClinicalStudy = new ClinicalStudy(clinicalStudiesNameFromAutoGeneratedLong);
        ClinicalStudyInfo clinicalStudyInfo = infoStudyRepository.getClinicalStudyInfo(acuityClinicalStudy);

        if (clinicalStudyInfo == null) { // not found
            throw new NotFoundException("ClinicalStudyInfo: " + clinicalStudyId + " not found");
        }

        return clinicalStudyInfo;
    }

    public  <T extends AcuityObjectIdentity> Map<String, Long> countROIs(List<T> roisWithPermission) {
        return roisWithPermission
                .stream()
                .collect(Collectors.groupingBy(AcuityObjectIdentity::getSupertype, Collectors.counting()));
    }

    public StudyRules getStudyRules(Long studyId) {
        return infoRepository.getStudyRules(studyId);
    }

    public boolean limitXAxisToVisit(Datasets datasets) {
        return Optional.ofNullable(datasets.getDatasetsList())
                .map(datasetsList -> datasetsList.get(0))
                .map(AcuityObjectIdentityImpl::getId)
                .map(this::getStudyRules)
                .map(StudyRules::isLimitXAxisToVisit)
                .orElse(false);

    }
}
